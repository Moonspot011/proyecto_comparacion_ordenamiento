# -*- coding: utf-8 -*-
"""mergesort.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1962x0UNto5BJ_T0-b50cLBwstM5ye8Dw
"""

import random
import time
import sys
import matplotlib.pyplot as plt

#Funciones de generacion de datos
def generar_datos_aleatorios(tamaño):
    return [random.randint(0, 10000) for _ in range(tamaño)] #generar datos al azar del 0 al 10000, dependiendo el tamaño (cantidad)

def generar_datos_ordenados(tamaño):
    return list(range(tamaño))  #generar una secuencia de numeros del 0 hasta llegar al tamaño

def generar_datos_inversamente_ordenados(tamaño):
    return list(range(tamaño, 0, -1))  #generar una secuencia de numeros desde el 0 hasta el tamaño de forma descendiente

#Mergesort
def merge_sort(lista):
    if len(lista)<=1:
        return lista
    medio=len(lista)//2
    izquierda=merge_sort(lista[:medio])
    derecha=merge_sort(lista[medio:]) #divide la lista a la mitad, y asi con cada mitad hasta que haya solo 1 elemento

    return fusionar(izquierda, derecha) #fusiona las sublistas ya ordenadas

def fusionar(izquierda, derecha):
    resultado=[]
    i=j=0
    while i<len(izquierda) and j<len(derecha): #recorre las listas izquierda y derecha para comparar y ordenar los elementos
        if izquierda[i]<derecha[j]:
            resultado.append(izquierda[i])
            i+=1
        else:
            resultado.append(derecha[j])
            j+=1
    resultado.extend(izquierda[i:])
    resultado.extend(derecha[j:])
    return resultado #una vez que una lista se termina, agrega lo que falta de la otra

#Pruebas de rendimiento
def rendimiento_a_prueba(nombre_tipo, generador, tamaños):  #generar listas de distintos tamaños
    tiempos=[]
    memorias=[]
    for tamaño in tamaños:
        datos=generador(tamaño)
        inicio=time.time()
        resultado=merge_sort(datos)
        fin=time.time()
        tiempo=fin-inicio  #tiempo que tarda en ordenar
        memoria=sys.getsizeof(resultado)   #memoria usada para el resultado
        tiempos.append(tiempo)
        memorias.append(memoria/1024)  #convertir los resultados de memoria a KiB
        print(f"{nombre_tipo}-Tamaño: {tamaño}, Tiempo: {tiempo:.5f} s, Memoria: {memoria / 1024:.2f} KiB")
    return tiempos, memorias

#Ejecucion de pruebas
tamaños_prueba=[100, 1000, 5000, 10000, 20000] #cantidad de datos pequeños y grandes

tipos_datos={  #tipos de datos a probar
    "Aleatorios":generar_datos_aleatorios,
    "Ordenados":generar_datos_ordenados,
    "Inversamente ordenados":generar_datos_inversamente_ordenados
}

resultados_tiempos={}
resultados_memorias={}

for tipo, funcion in tipos_datos.items(): #pruebas de los datos en base a su tipo, la funcion que corrresponde y la cantidad para cada caso
    tiempos, memorias=rendimiento_a_prueba(tipo, funcion, tamaños_prueba)
    resultados_tiempos[tipo]=tiempos
    resultados_memorias[tipo]=memorias  #arreglos con los resultados de tiempo y memoria de los datos

#Graficos
plt.figure(figsize=(12, 5)) #visualizacion de resultados

plt.subplot(1, 2, 1) #grafico de tiempo
for tipo, tiempos in resultados_tiempos.items():
    plt.plot(tamaños_prueba, tiempos, label=tipo)
plt.title("Tiempo de ejecucion de Mergesort")
plt.xlabel("Tamaño del conjunto de datos")
plt.ylabel("Tiempo (segundos)")
plt.legend()

plt.subplot(1, 2, 2) #grafico de memoria
for tipo, mem in resultados_memorias.items():
    plt.plot(tamaños_prueba, mem, label=tipo)
plt.title("Uso de memoria de mergesort")
plt.xlabel("Tamaño del conjunto de datos")
plt.ylabel("Memoria (KiB)")
plt.legend()

plt.tight_layout()
plt.show()